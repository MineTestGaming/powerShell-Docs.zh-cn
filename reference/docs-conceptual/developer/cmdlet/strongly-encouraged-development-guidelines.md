---
title: 强烈建议开发指南 |Microsoft Docs
ms.date: 09/13/2016
ms.openlocfilehash: 02488fea557b42ed30ea5cfde177b3efe0b3f559
ms.sourcegitcommit: 0907b8c6322d2c7c61b17f8168d53452c8964b41
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/05/2020
ms.locfileid: "87787812"
---
# <a name="strongly-encouraged-development-guidelines"></a><span data-ttu-id="51ca5-102">强烈建议的开发指南</span><span class="sxs-lookup"><span data-stu-id="51ca5-102">Strongly Encouraged Development Guidelines</span></span>

<span data-ttu-id="51ca5-103">本部分介绍编写 cmdlet 时应遵循的准则。</span><span class="sxs-lookup"><span data-stu-id="51ca5-103">This section describes guidelines that you should follow when you write your cmdlets.</span></span> <span data-ttu-id="51ca5-104">它们分为准则，用于设计 cmdlet 以及编写 cmdlet 代码的准则。</span><span class="sxs-lookup"><span data-stu-id="51ca5-104">They are separated into guidelines for designing cmdlets and guidelines for writing your cmdlet code.</span></span> <span data-ttu-id="51ca5-105">你可能会发现这些指南不适用于每个方案。</span><span class="sxs-lookup"><span data-stu-id="51ca5-105">You might find that these guidelines are not applicable for every scenario.</span></span> <span data-ttu-id="51ca5-106">但是，如果它们确实适用，并且你未遵循这些指导原则，则用户在使用 cmdlet 时可能会遇到不佳的体验。</span><span class="sxs-lookup"><span data-stu-id="51ca5-106">However, if they do apply and you do not follow these guidelines, your users might have a poor experience when they use your cmdlets.</span></span>

## <a name="design-guidelines"></a><span data-ttu-id="51ca5-107">设计准则</span><span class="sxs-lookup"><span data-stu-id="51ca5-107">Design Guidelines</span></span>

- [<span data-ttu-id="51ca5-108">为 Cmdlet 名称使用特定名词 (SD01) </span><span class="sxs-lookup"><span data-stu-id="51ca5-108">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>](./strongly-encouraged-development-guidelines.md#use-a-specific-noun-for-a-cmdlet-name-sd01)

- [<span data-ttu-id="51ca5-109">对 Cmdlet 名称使用 Pascal 大小写 (SD02) </span><span class="sxs-lookup"><span data-stu-id="51ca5-109">Use Pascal Case for Cmdlet Names (SD02)</span></span>](./strongly-encouraged-development-guidelines.md#use-pascal-case-for-cmdlet-names-sd02)

- [<span data-ttu-id="51ca5-110">参数设计准则 (SD03) </span><span class="sxs-lookup"><span data-stu-id="51ca5-110">Parameter Design Guidelines (SD03)</span></span>](./strongly-encouraged-development-guidelines.md#parameter-design-guidelines-sd03)

- [<span data-ttu-id="51ca5-111">向用户 (SD04 提供反馈) </span><span class="sxs-lookup"><span data-stu-id="51ca5-111">Provide Feedback to the User (SD04)</span></span>](./strongly-encouraged-development-guidelines.md#provide-feedback-to-the-user-sd04)

- [<span data-ttu-id="51ca5-112"> (SD05 创建 Cmdlet 帮助文件) </span><span class="sxs-lookup"><span data-stu-id="51ca5-112">Create a Cmdlet Help File (SD05)</span></span>](./strongly-encouraged-development-guidelines.md#create-a-cmdlet-help-file-sd05)

## <a name="code-guidelines"></a><span data-ttu-id="51ca5-113">代码准则</span><span class="sxs-lookup"><span data-stu-id="51ca5-113">Code Guidelines</span></span>

- [<span data-ttu-id="51ca5-114">编码参数 (SC01) </span><span class="sxs-lookup"><span data-stu-id="51ca5-114">Coding Parameters (SC01)</span></span>](./strongly-encouraged-development-guidelines.md#coding-parameters-sc01)

- [<span data-ttu-id="51ca5-115">支持定义良好的管道输入 (SC02) </span><span class="sxs-lookup"><span data-stu-id="51ca5-115">Support Well Defined Pipeline Input (SC02)</span></span>](./strongly-encouraged-development-guidelines.md#support-well-defined-pipeline-input-sc02)

- [<span data-ttu-id="51ca5-116">将单个记录写入管道 (SC03) </span><span class="sxs-lookup"><span data-stu-id="51ca5-116">Write Single Records to the Pipeline (SC03)</span></span>](./strongly-encouraged-development-guidelines.md#write-single-records-to-the-pipeline-sc03)

- [<span data-ttu-id="51ca5-117">使 Cmdlet 不区分大小写，不区分大小写 (SC04) </span><span class="sxs-lookup"><span data-stu-id="51ca5-117">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>](./strongly-encouraged-development-guidelines.md#make-cmdlets-case-insensitive-and-case-preserving-sc04)

## <a name="design-guidelines"></a><span data-ttu-id="51ca5-118">设计准则</span><span class="sxs-lookup"><span data-stu-id="51ca5-118">Design Guidelines</span></span>

<span data-ttu-id="51ca5-119">设计 cmdlet 时应遵循以下指导原则，以确保在使用 cmdlet 和其他 cmdlet 之间保持一致的用户体验。</span><span class="sxs-lookup"><span data-stu-id="51ca5-119">The following guidelines should be followed when designing cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="51ca5-120">如果找到适用于你的情况的设计准则，请务必查看类似准则的代码准则。</span><span class="sxs-lookup"><span data-stu-id="51ca5-120">When you find a Design guideline that applies to your situation, be sure to look at the Code guidelines for similar guidelines.</span></span>

### <a name="use-a-specific-noun-for-a-cmdlet-name-sd01"></a><span data-ttu-id="51ca5-121">为 Cmdlet 名称使用特定名词 (SD01) </span><span class="sxs-lookup"><span data-stu-id="51ca5-121">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>

<span data-ttu-id="51ca5-122">Cmdlet 命名中使用的名词需要是非常具体的，以便用户能够发现你的 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="51ca5-122">Nouns used in cmdlet naming need to be very specific so that the user can discover your cmdlets.</span></span> <span data-ttu-id="51ca5-123">将泛型名词（例如 "server"）的前缀作为产品名称的缩写形式。</span><span class="sxs-lookup"><span data-stu-id="51ca5-123">Prefix generic nouns such as "server" with a shortened version of the product name.</span></span> <span data-ttu-id="51ca5-124">例如，如果名词引用运行 Microsoft SQL Server 实例的服务器，请使用名词，如 "SQLServer"。</span><span class="sxs-lookup"><span data-stu-id="51ca5-124">For example, if a noun refers to a server that is running an instance of Microsoft SQL Server, use a noun such as "SQLServer".</span></span> <span data-ttu-id="51ca5-125">特定名词和批准的动词的简短列表组合使用户能够快速发现并预测功能，同时避免 cmdlet 名称之间的重复。</span><span class="sxs-lookup"><span data-stu-id="51ca5-125">The combination of specific nouns and the short list of approved verbs enable the user to quickly discover and anticipate functionality while avoiding duplication among cmdlet names.</span></span>

<span data-ttu-id="51ca5-126">为了增强用户体验，你为 cmdlet 名称选择的名词应为单数形式。</span><span class="sxs-lookup"><span data-stu-id="51ca5-126">To enhance the user experience, the noun that you choose for a cmdlet name should be singular.</span></span> <span data-ttu-id="51ca5-127">例如，使用名称 `Get-Process` 而不是**进程**。</span><span class="sxs-lookup"><span data-stu-id="51ca5-127">For example, use the name `Get-Process` instead of **Get-Processes**.</span></span> <span data-ttu-id="51ca5-128">最好对所有 cmdlet 名称遵循此规则，即使 cmdlet 可能会对多个项执行操作。</span><span class="sxs-lookup"><span data-stu-id="51ca5-128">It is best to follow this rule for all cmdlet names, even when a cmdlet is likely to act upon more than one item.</span></span>

### <a name="use-pascal-case-for-cmdlet-names-sd02"></a><span data-ttu-id="51ca5-129">对 Cmdlet 名称使用 Pascal 大小写 (SD02) </span><span class="sxs-lookup"><span data-stu-id="51ca5-129">Use Pascal Case for Cmdlet Names (SD02)</span></span>

<span data-ttu-id="51ca5-130">对于参数名称使用 Pascal 大小写。</span><span class="sxs-lookup"><span data-stu-id="51ca5-130">Use Pascal case for parameter names.</span></span> <span data-ttu-id="51ca5-131">换言之，将动词的第一个字母和名词中使用的所有字词都大写。</span><span class="sxs-lookup"><span data-stu-id="51ca5-131">In other words, capitalize the first letter of verb and all terms used in the noun.</span></span> <span data-ttu-id="51ca5-132">例如“`Clear-ItemProperty`”。</span><span class="sxs-lookup"><span data-stu-id="51ca5-132">For example, "`Clear-ItemProperty`".</span></span>

### <a name="parameter-design-guidelines-sd03"></a><span data-ttu-id="51ca5-133">参数设计准则 (SD03) </span><span class="sxs-lookup"><span data-stu-id="51ca5-133">Parameter Design Guidelines (SD03)</span></span>

<span data-ttu-id="51ca5-134">Cmdlet 需要用于接收必须操作的数据的参数，以及指示用于确定操作特征的信息的参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-134">A cmdlet needs parameters that receive the data on which it must operate, and parameters that indicate information that is used to determine the characteristics of the operation.</span></span> <span data-ttu-id="51ca5-135">例如，一个 cmdlet 可能有一个 `Name` 从管道接收数据的参数，该 cmdlet 可能有一个 `Force` 参数，用于指示可以强制该 cmdlet 执行其操作。</span><span class="sxs-lookup"><span data-stu-id="51ca5-135">For example, a cmdlet might have a `Name` parameter that receives data from the pipeline, and the cmdlet might have a `Force` parameter to indicate that the cmdlet can be forced to perform its operation.</span></span> <span data-ttu-id="51ca5-136">Cmdlet 可以定义的参数数量没有限制。</span><span class="sxs-lookup"><span data-stu-id="51ca5-136">There is no limit to the number of parameters that a cmdlet can define.</span></span>

#### <a name="use-standard-parameter-names"></a><span data-ttu-id="51ca5-137">使用标准参数名称</span><span class="sxs-lookup"><span data-stu-id="51ca5-137">Use Standard Parameter Names</span></span>

<span data-ttu-id="51ca5-138">你的 cmdlet 应使用标准参数名称，以便用户可以快速确定特定参数的含义。</span><span class="sxs-lookup"><span data-stu-id="51ca5-138">Your cmdlet should use standard parameter names so that the user can quickly determine what a particular parameter means.</span></span> <span data-ttu-id="51ca5-139">如果需要更具体的名称，请使用标准参数名称，然后将更具体的名称指定为别名。</span><span class="sxs-lookup"><span data-stu-id="51ca5-139">If a more specific name is required, use a standard parameter name, and then specify a more specific name as an alias.</span></span> <span data-ttu-id="51ca5-140">例如， `Get-Service` cmdlet 具有一个参数，该参数具有一个通用名称 (`Name`) 和更具体的别名 (`ServiceName`) 。</span><span class="sxs-lookup"><span data-stu-id="51ca5-140">For example, the `Get-Service` cmdlet has a  parameter that has a generic name (`Name`) and a more specific alias (`ServiceName`).</span></span> <span data-ttu-id="51ca5-141">这两个术语可用于指定参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-141">Both terms can be used to specify the parameter.</span></span>

<span data-ttu-id="51ca5-142">有关参数名称及其数据类型的详细信息，请参阅[Cmdlet 参数名称和功能准则](./standard-cmdlet-parameter-names-and-types.md)。</span><span class="sxs-lookup"><span data-stu-id="51ca5-142">For more information about parameter names and their data types, see [Cmdlet Parameter Name and Functionality Guidelines](./standard-cmdlet-parameter-names-and-types.md).</span></span>

#### <a name="use-singular-parameter-names"></a><span data-ttu-id="51ca5-143">使用单数参数名称</span><span class="sxs-lookup"><span data-stu-id="51ca5-143">Use Singular Parameter Names</span></span>

<span data-ttu-id="51ca5-144">避免对值为单个元素的参数使用复数名称。</span><span class="sxs-lookup"><span data-stu-id="51ca5-144">Avoid using plural names for parameters whose value is a single element.</span></span> <span data-ttu-id="51ca5-145">这包括采用数组或列表的参数，因为用户可能会提供只包含一个元素的数组或列表。</span><span class="sxs-lookup"><span data-stu-id="51ca5-145">This includes parameters that take arrays or lists because the user might supply an array or list with only one element.</span></span>

<span data-ttu-id="51ca5-146">复数参数名称只能在参数值始终为多元素值的情况下使用。</span><span class="sxs-lookup"><span data-stu-id="51ca5-146">Plural parameter names should be used only in those cases where the value of the parameter is always a multiple-element value.</span></span> <span data-ttu-id="51ca5-147">在这些情况下，cmdlet 应验证是否提供了多个元素，如果未提供多个元素，则 cmdlet 应向用户显示警告。</span><span class="sxs-lookup"><span data-stu-id="51ca5-147">In these cases, the cmdlet should verify that multiple elements are supplied, and the cmdlet should display a warning to the user if multiple elements are not supplied.</span></span>

#### <a name="use-pascal-case-for-parameter-names"></a><span data-ttu-id="51ca5-148">对于参数名称使用 Pascal 大小写</span><span class="sxs-lookup"><span data-stu-id="51ca5-148">Use Pascal Case for Parameter Names</span></span>

<span data-ttu-id="51ca5-149">对于参数名称使用 Pascal 大小写。</span><span class="sxs-lookup"><span data-stu-id="51ca5-149">Use Pascal case for parameter names.</span></span> <span data-ttu-id="51ca5-150">换句话说，将参数名称中每个单词的首字母大写，包括名称的第一个字母。</span><span class="sxs-lookup"><span data-stu-id="51ca5-150">In other words, capitalize the first letter of each word in the parameter name, including the first letter of the name.</span></span> <span data-ttu-id="51ca5-151">例如，参数名称 `ErrorAction` 使用正确的大小写。</span><span class="sxs-lookup"><span data-stu-id="51ca5-151">For example, the parameter name `ErrorAction` uses the correct capitalization.</span></span> <span data-ttu-id="51ca5-152">以下参数名称使用了不正确的大小写：</span><span class="sxs-lookup"><span data-stu-id="51ca5-152">The following parameter names use incorrect capitalization:</span></span>

- `errorAction`

- `erroraction`

#### <a name="parameters-that-take-a-list-of-options"></a><span data-ttu-id="51ca5-153">采用选项列表的参数</span><span class="sxs-lookup"><span data-stu-id="51ca5-153">Parameters That Take a List of Options</span></span>

<span data-ttu-id="51ca5-154">可以通过两种方法来创建参数，该参数的值可以从一组选项中进行选择。</span><span class="sxs-lookup"><span data-stu-id="51ca5-154">There are two ways to create a parameter whose value can be selected from a set of options.</span></span>

- <span data-ttu-id="51ca5-155">定义枚举类型 (或使用现有枚举类型) 指定有效值。</span><span class="sxs-lookup"><span data-stu-id="51ca5-155">Define an enumeration type (or use an existing enumeration type) that specifies the valid values.</span></span> <span data-ttu-id="51ca5-156">然后，使用枚举类型创建该类型的参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-156">Then, use the enumeration type to create a parameter of that type.</span></span>

- <span data-ttu-id="51ca5-157">将**ValidateSet**特性添加到参数声明。</span><span class="sxs-lookup"><span data-stu-id="51ca5-157">Add the **ValidateSet** attribute to the parameter declaration.</span></span> <span data-ttu-id="51ca5-158">有关此属性的详细信息，请参阅[ValidateSet 属性声明](./validateset-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="51ca5-158">For more information about this attribute, see [ValidateSet Attribute Declaration](./validateset-attribute-declaration.md).</span></span>

#### <a name="use-standard-types-for-parameters"></a><span data-ttu-id="51ca5-159">使用参数的标准类型</span><span class="sxs-lookup"><span data-stu-id="51ca5-159">Use Standard Types for Parameters</span></span>

<span data-ttu-id="51ca5-160">若要确保与其他 cmdlet 的一致性，请在可能的情况下使用标准类型的参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-160">To ensure consistency with other cmdlets, use standard types for parameters where ever possible.</span></span> <span data-ttu-id="51ca5-161">有关应该用于不同参数的类型的详细信息，请参阅[标准 Cmdlet 参数名称和类型](./standard-cmdlet-parameter-names-and-types.md)。</span><span class="sxs-lookup"><span data-stu-id="51ca5-161">For more information about the types that should be used for different parameter, see [Standard Cmdlet Parameter Names and Types](./standard-cmdlet-parameter-names-and-types.md).</span></span> <span data-ttu-id="51ca5-162">本主题提供了一些主题链接，这些主题描述了标准参数组的名称和 .NET Framework 类型，例如 "活动参数"。</span><span class="sxs-lookup"><span data-stu-id="51ca5-162">This topic provides links to several topics that describe the names and .NET Framework types for groups of standard parameters, such as the "activity parameters".</span></span>

#### <a name="use-strongly-typed-net-framework-types"></a><span data-ttu-id="51ca5-163">使用强类型 .NET Framework 类型</span><span class="sxs-lookup"><span data-stu-id="51ca5-163">Use Strongly-Typed .NET Framework Types</span></span>

<span data-ttu-id="51ca5-164">应将参数定义为 .NET Framework 类型，以提供更好的参数验证。</span><span class="sxs-lookup"><span data-stu-id="51ca5-164">Parameters should be defined as .NET Framework types to provide better parameter validation.</span></span> <span data-ttu-id="51ca5-165">例如，限制为一组值中的一个值的参数应定义为枚举类型。</span><span class="sxs-lookup"><span data-stu-id="51ca5-165">For example, parameters that are restricted to one value from a set of values should be defined as an enumeration type.</span></span> <span data-ttu-id="51ca5-166">若要支持 (URI) 值的统一资源标识符，请将参数定义为[system.string 类型。](/dotnet/api/System.Uri)</span><span class="sxs-lookup"><span data-stu-id="51ca5-166">To support a Uniform Resource Identifier (URI) value, define the parameter as a [System.Uri](/dotnet/api/System.Uri) type.</span></span> <span data-ttu-id="51ca5-167">避免为所有自由格式的文本属性提供基本的字符串参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-167">Avoid basic string parameters for all but free-form text properties.</span></span>

#### <a name="use-consistent-parameter-types"></a><span data-ttu-id="51ca5-168">使用一致的参数类型</span><span class="sxs-lookup"><span data-stu-id="51ca5-168">Use Consistent Parameter Types</span></span>

<span data-ttu-id="51ca5-169">当多个 cmdlet 使用同一个参数时，请始终使用相同的参数类型。</span><span class="sxs-lookup"><span data-stu-id="51ca5-169">When the same parameter is used by multiple cmdlets, always use the same parameter type.</span></span>  <span data-ttu-id="51ca5-170">例如，如果 `Process` 参数是一个 cmdlet 的[system.object](/dotnet/api/System.Int16)类型，请不要使 `Process` 另一个 Cmdlet 的参数成为[Uint16](/dotnet/api/System.UInt16)类型。</span><span class="sxs-lookup"><span data-stu-id="51ca5-170">For example, if the `Process` parameter is an [System.Int16](/dotnet/api/System.Int16) type for one cmdlet, do not make the `Process` parameter for another cmdlet a [System.Uint16](/dotnet/api/System.UInt16) type.</span></span>

#### <a name="parameters-that-take-true-and-false"></a><span data-ttu-id="51ca5-171">采用 True 和 False 的参数</span><span class="sxs-lookup"><span data-stu-id="51ca5-171">Parameters That Take True and False</span></span>

<span data-ttu-id="51ca5-172">如果参数仅使用 `true` 和 `false` ，请将参数定义为类型[SwitchParameter](/dotnet/api/System.Management.Automation.SwitchParameter)。</span><span class="sxs-lookup"><span data-stu-id="51ca5-172">If your parameter takes only `true` and `false`, define the parameter as type [System.Management.Automation.SwitchParameter](/dotnet/api/System.Management.Automation.SwitchParameter).</span></span> <span data-ttu-id="51ca5-173">开关参数 `true` 在命令中指定时被视为。</span><span class="sxs-lookup"><span data-stu-id="51ca5-173">A switch parameter is treated as `true` when it is specified in a command.</span></span> <span data-ttu-id="51ca5-174">如果命令中未包含该参数，则 Windows PowerShell 会将参数的值视为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="51ca5-174">If the parameter is not included in a command, Windows PowerShell considers the value of the parameter to be `false`.</span></span> <span data-ttu-id="51ca5-175">不要定义布尔参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-175">Do not define Boolean parameters.</span></span>

<span data-ttu-id="51ca5-176">如果参数需要区分三个值： $true、$false 和 "未指定"，则定义类型为 Null 的参数 \<bool> 。</span><span class="sxs-lookup"><span data-stu-id="51ca5-176">If your parameter needs to differentiate between 3 values: $true, $false and "unspecified", then define a parameter of type Nullable\<bool>.</span></span>  <span data-ttu-id="51ca5-177">当 cmdlet 可以修改对象的布尔属性时，通常会出现第三个 "未指定" 值。</span><span class="sxs-lookup"><span data-stu-id="51ca5-177">The need for a 3rd, "unspecified" value typically occurs when the cmdlet can modify a Boolean property of an object.</span></span> <span data-ttu-id="51ca5-178">在这种情况下，"未指定" 表示不更改属性的当前值。</span><span class="sxs-lookup"><span data-stu-id="51ca5-178">In this case "unspecified" means to not change the current value of the property.</span></span>

#### <a name="support-arrays-for-parameters"></a><span data-ttu-id="51ca5-179">支持参数的数组</span><span class="sxs-lookup"><span data-stu-id="51ca5-179">Support Arrays for Parameters</span></span>

<span data-ttu-id="51ca5-180">用户经常需要对多个参数执行相同的操作。</span><span class="sxs-lookup"><span data-stu-id="51ca5-180">Frequently, users must perform the same operation against multiple arguments.</span></span> <span data-ttu-id="51ca5-181">对于这些用户，cmdlet 应接受一个数组作为参数输入，以便用户可以将参数作为 Windows PowerShell 变量传递到参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-181">For these users, a cmdlet should accept an array as parameter input so that a user can pass the arguments into the parameter as a Windows PowerShell variable.</span></span> <span data-ttu-id="51ca5-182">例如，对于标识要检索的进程的名称的字符串， [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet 使用数组。</span><span class="sxs-lookup"><span data-stu-id="51ca5-182">For example, the [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet uses an array for the strings that identify the names of the processes to retrieve.</span></span>

#### <a name="support-the-passthru-parameter"></a><span data-ttu-id="51ca5-183">支持 PassThru 参数</span><span class="sxs-lookup"><span data-stu-id="51ca5-183">Support the PassThru Parameter</span></span>

<span data-ttu-id="51ca5-184">默认情况下，修改系统的许多 cmdlet （如[Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet）都充当对象的 "接收器"，不返回结果。</span><span class="sxs-lookup"><span data-stu-id="51ca5-184">By default, many cmdlets that modify the system, such as the [Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet, act as "sinks" for objects and do not return a result.</span></span> <span data-ttu-id="51ca5-185">这些 cmdlet 应实现 `PassThru` 参数，以强制 cmdlet 返回对象。</span><span class="sxs-lookup"><span data-stu-id="51ca5-185">These cmdlet should implement the `PassThru` parameter to force the cmdlet to return an object.</span></span> <span data-ttu-id="51ca5-186">`PassThru`指定参数时，该 cmdlet 将使用对[WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject)方法的调用来返回一个对象。</span><span class="sxs-lookup"><span data-stu-id="51ca5-186">When the `PassThru` parameter is specified, the cmdlet returns an object by using a call to the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="51ca5-187">例如，以下命令将停止 Calc 进程，并将生成的进程传递给管道。</span><span class="sxs-lookup"><span data-stu-id="51ca5-187">For example, the following command stops the Calc process and passes the resultant process to the pipeline.</span></span>

```powershell
Stop-Process calc -passthru
```

<span data-ttu-id="51ca5-188">在大多数情况下，添加、设置和新的 cmdlet 应支持 `PassThru` 参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-188">In most cases, Add, Set, and New cmdlets should support a `PassThru` parameter.</span></span>

#### <a name="support-parameter-sets"></a><span data-ttu-id="51ca5-189">支持参数集</span><span class="sxs-lookup"><span data-stu-id="51ca5-189">Support Parameter Sets</span></span>

<span data-ttu-id="51ca5-190">Cmdlet 用于实现单一目的。</span><span class="sxs-lookup"><span data-stu-id="51ca5-190">A cmdlet is intended to accomplish a single purpose.</span></span> <span data-ttu-id="51ca5-191">但是，通常有多种方法来描述操作或操作目标。</span><span class="sxs-lookup"><span data-stu-id="51ca5-191">However, there is frequently more than one way to describe the operation or the operation target.</span></span> <span data-ttu-id="51ca5-192">例如，进程可以通过其名称、其标识符或进程对象进行标识。</span><span class="sxs-lookup"><span data-stu-id="51ca5-192">For example, a process might be identified by its name, by its identifier, or by a process object.</span></span> <span data-ttu-id="51ca5-193">该 cmdlet 应支持其目标的所有合理表示形式。</span><span class="sxs-lookup"><span data-stu-id="51ca5-193">The cmdlet should support all the reasonable representations of its targets.</span></span> <span data-ttu-id="51ca5-194">通常，该 cmdlet 通过指定 (称为参数集) 的参数集来满足此要求。</span><span class="sxs-lookup"><span data-stu-id="51ca5-194">Normally, the cmdlet satisfies this requirement by specifying sets of parameters (referred to as parameter sets) that operate together.</span></span> <span data-ttu-id="51ca5-195">单个参数可以属于任意数量的参数集。</span><span class="sxs-lookup"><span data-stu-id="51ca5-195">A single parameter can belong to any number of parameter sets.</span></span> <span data-ttu-id="51ca5-196">有关参数集的详细信息，请参阅[Cmdlet 参数集](./cmdlet-parameter-sets.md)。</span><span class="sxs-lookup"><span data-stu-id="51ca5-196">For more information about parameter sets, see [Cmdlet Parameter Sets](./cmdlet-parameter-sets.md).</span></span>

<span data-ttu-id="51ca5-197">指定参数集时，请在 "设置为 ValueFromPipeline" 中仅设置一个参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-197">When you specify parameter sets, set only one parameter in the set to ValueFromPipeline.</span></span> <span data-ttu-id="51ca5-198">有关如何声明**参数**属性的详细信息，请参阅[ParameterAttribute 声明](./parameter-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="51ca5-198">For more information about how to declare the **Parameter** attribute, see [ParameterAttribute Declaration](./parameter-attribute-declaration.md).</span></span>

<span data-ttu-id="51ca5-199">使用参数集时，默认参数集由**Cmdlet**特性定义。</span><span class="sxs-lookup"><span data-stu-id="51ca5-199">When parameter sets are used, the default parameter set is defined by the **Cmdlet** attribute.</span></span> <span data-ttu-id="51ca5-200">默认参数集应包含交互 Windows PowerShell 会话中最可能使用的参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-200">The default parameter set should include the parameters most likely to be used in an interactive Windows PowerShell session.</span></span> <span data-ttu-id="51ca5-201">有关如何声明**Cmdlet**特性的详细信息，请参阅[CmdletAttribute 声明](./cmdlet-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="51ca5-201">For more information about how to declare the **Cmdlet** attribute, see [CmdletAttribute Declaration](./cmdlet-attribute-declaration.md).</span></span>

### <a name="provide-feedback-to-the-user-sd04"></a><span data-ttu-id="51ca5-202">向用户 (SD04 提供反馈) </span><span class="sxs-lookup"><span data-stu-id="51ca5-202">Provide Feedback to the User (SD04)</span></span>

<span data-ttu-id="51ca5-203">使用此部分中的指导原则向用户提供反馈。</span><span class="sxs-lookup"><span data-stu-id="51ca5-203">Use the guidelines in this section to provide feedback to the user.</span></span> <span data-ttu-id="51ca5-204">此反馈允许用户了解系统中发生的情况，并做出更好的管理决策。</span><span class="sxs-lookup"><span data-stu-id="51ca5-204">This feedback allows the user to be aware of what is occurring in the system and to make better administrative decisions.</span></span>

<span data-ttu-id="51ca5-205">Windows PowerShell 运行时允许用户指定如何 `Write` 通过设置首选项变量来处理对方法的每个调用的输出。</span><span class="sxs-lookup"><span data-stu-id="51ca5-205">The Windows PowerShell runtime allows a user to specify how to handle output from each call to the `Write` method by setting a preference variable.</span></span> <span data-ttu-id="51ca5-206">用户可以设置多个首选项变量，包括确定系统是否应显示信息的变量和确定系统是否应在采取进一步操作之前查询用户的变量。</span><span class="sxs-lookup"><span data-stu-id="51ca5-206">The user can set several preference variables, including a variable that determines whether the system should display information and a variable that determines whether the system should query the user before taking further action.</span></span>

#### <a name="support-the-writewarning-writeverbose-and-writedebug-methods"></a><span data-ttu-id="51ca5-207">支持 WriteWarning、WriteVerbose 和 WriteDebug 方法</span><span class="sxs-lookup"><span data-stu-id="51ca5-207">Support the WriteWarning, WriteVerbose, and WriteDebug Methods</span></span>

<span data-ttu-id="51ca5-208">当 cmdlet 要执行可能会产生意外结果的操作时，cmdlet 应调用[WriteWarning](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning)方法来调用。</span><span class="sxs-lookup"><span data-stu-id="51ca5-208">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteWarning](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) method when the cmdlet is about to perform an operation that might have an unintended result.</span></span> <span data-ttu-id="51ca5-209">例如，如果 cmdlet 即将覆盖只读文件，则 cmdlet 应调用此方法。</span><span class="sxs-lookup"><span data-stu-id="51ca5-209">For example, a cmdlet should call this method if the cmdlet is about to overwrite a read-only file.</span></span>

<span data-ttu-id="51ca5-210">如果用户需要有关 cmdlet 执行的操作的一些详细信息，则 cmdlet 应调用[WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose)方法。</span><span class="sxs-lookup"><span data-stu-id="51ca5-210">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method when the user requires some detail about what the cmdlet is doing.</span></span> <span data-ttu-id="51ca5-211">例如，如果 cmdlet 作者认为某些方案可能需要有关 cmdlet 执行的操作的详细信息，则 cmdlet 应调用此信息。</span><span class="sxs-lookup"><span data-stu-id="51ca5-211">For example, a cmdlet should call this information if the cmdlet author feels that there are scenarios that might require more information about what the cmdlet is doing.</span></span>

<span data-ttu-id="51ca5-212">当开发人员或产品支持工程师必须了解已损坏 cmdlet 操作时，该 cmdlet 应调用[WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug)方法。</span><span class="sxs-lookup"><span data-stu-id="51ca5-212">The cmdlet should call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method when a developer or product support engineer must understand what has corrupted the cmdlet operation.</span></span> <span data-ttu-id="51ca5-213">Cmdlet 不需要在调用[WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose)方法的同一代码中调用[WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug)方法，因为该 `Debug` 参数会同时提供这两种类型的信息，这是因为该参数提供了这两个信息集。</span><span class="sxs-lookup"><span data-stu-id="51ca5-213">It is not necessary for the cmdlet to call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method in the same code that calls the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method because the `Debug` parameter presents both sets of information.</span></span>

#### <a name="support-writeprogress-for-operations-that-take-a-long-time"></a><span data-ttu-id="51ca5-214">支持对耗时较长的操作的 WriteProgress</span><span class="sxs-lookup"><span data-stu-id="51ca5-214">Support WriteProgress for Operations that take a Long Time</span></span>

<span data-ttu-id="51ca5-215">需要很长时间才能完成并且无法在后台运行的 Cmdlet 操作应该支持通过定期调用[WriteProgress](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress)方法来报告进度。</span><span class="sxs-lookup"><span data-stu-id="51ca5-215">Cmdlet operations that take a long time to complete and that cannot run in the background should support progress reporting through periodic calls to the [System.Management.Automation.Cmdlet.WriteProgress](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) method.</span></span>

#### <a name="use-the-host-interfaces"></a><span data-ttu-id="51ca5-216">使用宿主接口</span><span class="sxs-lookup"><span data-stu-id="51ca5-216">Use the Host Interfaces</span></span>

<span data-ttu-id="51ca5-217">有时，cmdlet 必须直接与用户通信，而不是使用[系统管理](/dotnet/api/System.Management.Automation.Cmdlet)类支持的各种写入或应方法。</span><span class="sxs-lookup"><span data-stu-id="51ca5-217">Occasionally, a cmdlet must communicate directly with the user instead of by using the various Write or Should methods supported by the [System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet) class.</span></span> <span data-ttu-id="51ca5-218">在这种情况下，该 cmdlet 应派生自[PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet)类，并使用[PSCmdlet \*](/dotnet/api/System.Management.Automation.PSCmdlet.Host)属性来实现。</span><span class="sxs-lookup"><span data-stu-id="51ca5-218">In this case, the cmdlet should derive from the [System.Management.Automation.PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) class and use the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="51ca5-219">此属性支持不同级别的通信类型，包括 PromptForChoice、Prompt 和 WriteLine/ReadLine 类型。</span><span class="sxs-lookup"><span data-stu-id="51ca5-219">This property supports different levels of communication type, including the PromptForChoice, Prompt, and WriteLine/ReadLine types.</span></span> <span data-ttu-id="51ca5-220">在最具体的层面上，它还提供了读取和写入单个密钥并处理缓冲区的方法。</span><span class="sxs-lookup"><span data-stu-id="51ca5-220">At the most specific level, it also provides ways to read and write individual keys and to deal with buffers.</span></span>

<span data-ttu-id="51ca5-221">除非 cmdlet 专门用于生成图形用户界面 (GUI) ，否则它不应使用[PSCmdlet \*](/dotnet/api/System.Management.Automation.PSCmdlet.Host)属性来绕过该主机。</span><span class="sxs-lookup"><span data-stu-id="51ca5-221">Unless a cmdlet is specifically designed to generate a graphical user interface (GUI), it should not bypass the host by using the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="51ca5-222">为生成 GUI 而设计的 cmdlet 的一个示例是 "[外](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView)" cmdlet。</span><span class="sxs-lookup"><span data-stu-id="51ca5-222">An example of a cmdlet that is designed to generate a GUI is the [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet.</span></span>

> [!NOTE]
> <span data-ttu-id="51ca5-223">Cmdlet 不应使用[系统控制台](/dotnet/api/System.Console)API。</span><span class="sxs-lookup"><span data-stu-id="51ca5-223">Cmdlets should not use the [System.Console](/dotnet/api/System.Console) API.</span></span>

### <a name="create-a-cmdlet-help-file-sd05"></a><span data-ttu-id="51ca5-224"> (SD05 创建 Cmdlet 帮助文件) </span><span class="sxs-lookup"><span data-stu-id="51ca5-224">Create a Cmdlet Help File (SD05)</span></span>

<span data-ttu-id="51ca5-225">对于每个 cmdlet 程序集，创建一个 Help.xml 文件，其中包含有关该 cmdlet 的信息。</span><span class="sxs-lookup"><span data-stu-id="51ca5-225">For each cmdlet assembly, create a Help.xml file that contains information about the cmdlet.</span></span> <span data-ttu-id="51ca5-226">此信息包括 cmdlet 的说明、cmdlet 的参数说明、cmdlet 使用的示例等。</span><span class="sxs-lookup"><span data-stu-id="51ca5-226">This information includes a description of the cmdlet, descriptions of the cmdlet's parameters, examples of the cmdlet's use, and more.</span></span>

## <a name="code-guidelines"></a><span data-ttu-id="51ca5-227">代码准则</span><span class="sxs-lookup"><span data-stu-id="51ca5-227">Code Guidelines</span></span>

<span data-ttu-id="51ca5-228">编写 cmdlet 时应遵循以下准则，以确保在使用 cmdlet 和其他 cmdlet 之间保持一致的用户体验。</span><span class="sxs-lookup"><span data-stu-id="51ca5-228">The following guidelines should be followed when coding cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="51ca5-229">如果你发现适用于你的情况的代码准则，请务必查看类似指导原则的设计指南。</span><span class="sxs-lookup"><span data-stu-id="51ca5-229">When you find a Code guideline that applies to your situation, be sure to look at the Design guidelines for similar guidelines.</span></span>

### <a name="coding-parameters-sc01"></a><span data-ttu-id="51ca5-230">编码参数 (SC01) </span><span class="sxs-lookup"><span data-stu-id="51ca5-230">Coding Parameters (SC01)</span></span>

<span data-ttu-id="51ca5-231">通过声明使用**parameter**特性修饰的 cmdlet 类的公共属性来定义参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-231">Define a parameter by declaring a public property of the cmdlet class that is decorated with the **Parameter** attribute.</span></span> <span data-ttu-id="51ca5-232">参数不一定是 cmdlet 的派生 .NET Framework 类的静态成员。</span><span class="sxs-lookup"><span data-stu-id="51ca5-232">Parameters do not have to be static members of the derived .NET Framework class for the cmdlet.</span></span> <span data-ttu-id="51ca5-233">有关如何声明**参数**属性的详细信息，请参阅[参数属性声明](./parameter-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="51ca5-233">For more information about how to declare the **Parameter** attribute, see [Parameter Attribute Declaration](./parameter-attribute-declaration.md).</span></span>

#### <a name="support-windows-powershell-paths"></a><span data-ttu-id="51ca5-234">支持 Windows PowerShell 路径</span><span class="sxs-lookup"><span data-stu-id="51ca5-234">Support Windows PowerShell Paths</span></span>

<span data-ttu-id="51ca5-235">Windows PowerShell 路径是用于规范化对命名空间的访问的机制。</span><span class="sxs-lookup"><span data-stu-id="51ca5-235">The Windows PowerShell path is the mechanism for normalizing access to namespaces.</span></span> <span data-ttu-id="51ca5-236">将 Windows PowerShell 路径分配到 cmdlet 中的参数时，用户可以定义一个自定义 "驱动器"，它充当特定路径的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="51ca5-236">When you assign a Windows PowerShell path to a parameter in the cmdlet, the user can define a custom "drive" that acts as a shortcut to a specific path.</span></span> <span data-ttu-id="51ca5-237">当用户指定此类驱动器时，可以通过一致的方式使用存储的数据（如注册表中的数据）。</span><span class="sxs-lookup"><span data-stu-id="51ca5-237">When a user designates such a drive, stored data, such as data in the Registry, can be used in a consistent way.</span></span>

<span data-ttu-id="51ca5-238">如果你的 cmdlet 允许用户指定文件或数据源，则它应定义类型为[system.string](/dotnet/api/System.String)的参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-238">If your cmdlet allows the user to specify a file or a data source, it should define a parameter of type [System.String](/dotnet/api/System.String).</span></span> <span data-ttu-id="51ca5-239">如果支持多个驱动器，则类型应为数组。</span><span class="sxs-lookup"><span data-stu-id="51ca5-239">If more than one drive is supported, the type should be an array.</span></span> <span data-ttu-id="51ca5-240">参数的名称应为 `Path` ，别名为 `PSPath` 。</span><span class="sxs-lookup"><span data-stu-id="51ca5-240">The name of the parameter should be `Path`, with an alias of `PSPath`.</span></span> <span data-ttu-id="51ca5-241">此外， `Path` 参数应支持通配符。</span><span class="sxs-lookup"><span data-stu-id="51ca5-241">Additionally, the `Path` parameter should support wildcard characters.</span></span> <span data-ttu-id="51ca5-242">如果不需要支持通配符，请定义 `LiteralPath` 参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-242">If support for wildcard characters is not required, define a `LiteralPath` parameter.</span></span>

<span data-ttu-id="51ca5-243">如果 cmdlet 读取或写入的数据必须是文件，则该 cmdlet 应接受 Windows PowerShell 路径输入，并且该 cmdlet 应使用[Sessionstate](/dotnet/api/System.Management.Automation.SessionState.Path)属性将 Windows powershell 路径转换为文件系统可识别的路径。</span><span class="sxs-lookup"><span data-stu-id="51ca5-243">If the data that the cmdlet reads or writes has to be a file, the cmdlet should accept Windows PowerShell path input, and the cmdlet should use the [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path) property to translate the Windows PowerShell paths into paths that the file system recognizes.</span></span> <span data-ttu-id="51ca5-244">具体的机制包括以下方法：</span><span class="sxs-lookup"><span data-stu-id="51ca5-244">The specific mechanisms include the following methods:</span></span>

- [<span data-ttu-id="51ca5-245">PSCmdlet. GetResolvedProviderPathFromPSPath。</span><span class="sxs-lookup"><span data-stu-id="51ca5-245">System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="51ca5-246">PSCmdlet. GetUnresolvedProviderPathFromPSPath。</span><span class="sxs-lookup"><span data-stu-id="51ca5-246">System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath)

- [<span data-ttu-id="51ca5-247">PathIntrinsics. GetResolvedProviderPathFromPSPath。</span><span class="sxs-lookup"><span data-stu-id="51ca5-247">System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="51ca5-248">PathIntrinsics. GetUnresolvedProviderPathFromPSPath。</span><span class="sxs-lookup"><span data-stu-id="51ca5-248">System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath)

<span data-ttu-id="51ca5-249">如果 cmdlet 读取或写入的数据只是一组字符串而不是文件，则该 cmdlet 应该使用提供程序内容信息 (`Content` 成员) 进行读取和写入。</span><span class="sxs-lookup"><span data-stu-id="51ca5-249">If the data that the cmdlet reads or writes is only a set of strings instead of a file, the cmdlet should use the provider content information (`Content` member) to read and write.</span></span> <span data-ttu-id="51ca5-250">此信息是从[CmdletProvider. InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider)属性获取的。</span><span class="sxs-lookup"><span data-stu-id="51ca5-250">This information is obtained from the [System.Management.Automation.Provider.CmdletProvider.InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) property.</span></span> <span data-ttu-id="51ca5-251">这些机制允许其他数据存储区参与数据的读取和写入。</span><span class="sxs-lookup"><span data-stu-id="51ca5-251">These mechanisms allow other data stores to participate in the reading and writing of data.</span></span>

#### <a name="support-wildcard-characters"></a><span data-ttu-id="51ca5-252">支持通配符</span><span class="sxs-lookup"><span data-stu-id="51ca5-252">Support Wildcard Characters</span></span>

<span data-ttu-id="51ca5-253">如果可能，cmdlet 应支持通配符。</span><span class="sxs-lookup"><span data-stu-id="51ca5-253">A cmdlet should support wildcard characters if possible.</span></span> <span data-ttu-id="51ca5-254">对通配符的支持出现在 cmdlet 中的多个位置 (尤其是在参数采用字符串来标识一组对象) 中的一个对象时。</span><span class="sxs-lookup"><span data-stu-id="51ca5-254">Support for wildcard characters occurs in many places in a cmdlet (especially when a parameter takes a string to identify one object from a set of objects).</span></span> <span data-ttu-id="51ca5-255">例如， [StopProc 教程](./stopproc-tutorial.md)中的示例**停止过程**cmdlet 定义了一个参数， `Name` 用于处理表示进程名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="51ca5-255">For example, the sample **Stop-Proc** cmdlet from the [StopProc Tutorial](./stopproc-tutorial.md) defines a `Name` parameter to handle strings that represent process names.</span></span> <span data-ttu-id="51ca5-256">此参数支持通配符，使用户能够轻松地指定要停止的进程。</span><span class="sxs-lookup"><span data-stu-id="51ca5-256">This parameter supports wildcard characters so that the user can easily specify the processes to stop.</span></span>

<span data-ttu-id="51ca5-257">当支持通配符时，cmdlet 操作通常会生成一个数组。</span><span class="sxs-lookup"><span data-stu-id="51ca5-257">When support for wildcard characters is available, a cmdlet operation usually produces an array.</span></span> <span data-ttu-id="51ca5-258">有时，如果支持数组，则没有意义，因为用户一次只能使用一个项。</span><span class="sxs-lookup"><span data-stu-id="51ca5-258">Occasionally, it does not make sense to support an array because the user might use only a single item at a time.</span></span> <span data-ttu-id="51ca5-259">例如，[设置位置](/powershell/module/Microsoft.PowerShell.Management/Set-Location)cmdlet 不需要支持数组，因为用户仅设置一个位置。</span><span class="sxs-lookup"><span data-stu-id="51ca5-259">For example, the [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet does not need to support an array because the user is setting only a single location.</span></span> <span data-ttu-id="51ca5-260">在这种情况下，该 cmdlet 仍支持通配符，但会强制将分辨率转换为单一位置。</span><span class="sxs-lookup"><span data-stu-id="51ca5-260">In this instance, the cmdlet still supports wildcard characters, but it forces resolution to a single location.</span></span>

<span data-ttu-id="51ca5-261">有关通配符模式的详细信息，请参阅[在 Cmdlet 参数中支持通配符](./supporting-wildcard-characters-in-cmdlet-parameters.md)。</span><span class="sxs-lookup"><span data-stu-id="51ca5-261">For more information about wildcard-character patterns, see [Supporting Wildcard Characters in Cmdlet Parameters](./supporting-wildcard-characters-in-cmdlet-parameters.md).</span></span>

#### <a name="defining-objects"></a><span data-ttu-id="51ca5-262">定义对象</span><span class="sxs-lookup"><span data-stu-id="51ca5-262">Defining Objects</span></span>

<span data-ttu-id="51ca5-263">本部分包含有关为 cmdlet 定义对象以及扩展现有对象的准则。</span><span class="sxs-lookup"><span data-stu-id="51ca5-263">This section contains guidelines for defining objects for cmdlets and for extending existing objects.</span></span>

##### <a name="define-standard-members"></a><span data-ttu-id="51ca5-264">定义标准成员</span><span class="sxs-lookup"><span data-stu-id="51ca5-264">Define Standard Members</span></span>

<span data-ttu-id="51ca5-265">定义标准成员以在自定义 Types.ps1xml 文件中扩展对象类型 (使用 Windows PowerShell Types.ps1xml 文件作为模板) 。</span><span class="sxs-lookup"><span data-stu-id="51ca5-265">Define standard members to extend an object type in a custom Types.ps1xml file (use the Windows PowerShell Types.ps1xml file as a template).</span></span> <span data-ttu-id="51ca5-266">标准成员由名称为 PSStandardMembers 的节点定义。</span><span class="sxs-lookup"><span data-stu-id="51ca5-266">Standard members are defined by a node with the name PSStandardMembers.</span></span> <span data-ttu-id="51ca5-267">这些定义允许其他 cmdlet 和 Windows PowerShell 运行时以一致的方式处理对象。</span><span class="sxs-lookup"><span data-stu-id="51ca5-267">These definitions allow other cmdlets and the Windows PowerShell runtime to work with your object in a consistent way.</span></span>

##### <a name="define-objectmembers-to-be-used-as-parameters"></a><span data-ttu-id="51ca5-268">定义要用作参数的 ObjectMembers</span><span class="sxs-lookup"><span data-stu-id="51ca5-268">Define ObjectMembers to Be Used as Parameters</span></span>

<span data-ttu-id="51ca5-269">如果要为 cmdlet 设计对象，请确保其成员直接映射到将使用它的 cmdlet 的参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-269">If you are designing an object for a cmdlet, ensure that its members map directly to the parameters of the cmdlets that will use it.</span></span> <span data-ttu-id="51ca5-270">通过此映射，可轻松地将对象发送到管道，并将其从一个 cmdlet 传递到另一个 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="51ca5-270">This mapping allows the object to be easily sent to the pipeline and to be passed from one cmdlet to another.</span></span>

<span data-ttu-id="51ca5-271">Cmdlet 返回的预先存在的 .NET Framework 对象常常缺少脚本开发人员或用户所需的一些重要或便捷的成员。</span><span class="sxs-lookup"><span data-stu-id="51ca5-271">Preexisting .NET Framework objects that are returned by cmdlets are frequently missing some important or convenient members that are needed by the script developer or user.</span></span> <span data-ttu-id="51ca5-272">这些缺少的成员对于显示和创建正确的成员名称尤其重要，这样就可以正确地将对象传递到管道。</span><span class="sxs-lookup"><span data-stu-id="51ca5-272">These missing members can be particularly important for display and for creating the correct member names so that the object can be correctly passed to the pipeline.</span></span> <span data-ttu-id="51ca5-273">创建一个自定义 Types.ps1xml 文件以记录这些必需成员。</span><span class="sxs-lookup"><span data-stu-id="51ca5-273">Create a custom Types.ps1xml file to document these required members.</span></span> <span data-ttu-id="51ca5-274">当你创建此文件时，建议采用以下命名约定： *<>*.Types.ps1xml Your_Product_Name。</span><span class="sxs-lookup"><span data-stu-id="51ca5-274">When you create this file, we recommend the following naming convention: *<Your_Product_Name>*.Types.ps1xml.</span></span>

<span data-ttu-id="51ca5-275">例如，你可以将 `Mode` 脚本属性添加到[FileInfo](/dotnet/api/System.IO.FileInfo)类型，以更清晰地显示文件的属性。</span><span class="sxs-lookup"><span data-stu-id="51ca5-275">For example, you could add a `Mode` script property to the [System.IO.FileInfo](/dotnet/api/System.IO.FileInfo) type to display the attributes of a file more clearly.</span></span> <span data-ttu-id="51ca5-276">此外，您还可以向 system.string `Count` 类型添加 alias [System.Array](/dotnet/api/System.Array)属性，以允许 (的属性名称的使用一致，而不是 `Length`) 。</span><span class="sxs-lookup"><span data-stu-id="51ca5-276">Additionally, you could add a `Count` alias property to the [System.Array](/dotnet/api/System.Array) type to allow the consistent use of that property name (instead of `Length`).</span></span>

##### <a name="implement-the-icomparable-interface"></a><span data-ttu-id="51ca5-277">实现 IComparable 接口</span><span class="sxs-lookup"><span data-stu-id="51ca5-277">Implement the IComparable Interface</span></span>

<span data-ttu-id="51ca5-278">在所有输出对象上实现[system.icomparable](/dotnet/api/System.IComparable)接口。</span><span class="sxs-lookup"><span data-stu-id="51ca5-278">Implement a [System.IComparable](/dotnet/api/System.IComparable) interface on all output objects.</span></span> <span data-ttu-id="51ca5-279">这样，就可以轻松地将输出对象输送到各种排序和分析 cmdlet 中。</span><span class="sxs-lookup"><span data-stu-id="51ca5-279">This allows the output objects to be easily piped to various sorting and analysis cmdlets.</span></span>

##### <a name="update-display-information"></a><span data-ttu-id="51ca5-280">更新显示信息</span><span class="sxs-lookup"><span data-stu-id="51ca5-280">Update Display Information</span></span>

<span data-ttu-id="51ca5-281">如果对象的显示未提供预期结果，请为该对象创建一个自定义 *\<YourProductName>*.Format.ps1xml 文件。</span><span class="sxs-lookup"><span data-stu-id="51ca5-281">If the display for an object does not provide the expected results, create a custom *\<YourProductName>*.Format.ps1xml file for that object.</span></span>

### <a name="support-well-defined-pipeline-input-sc02"></a><span data-ttu-id="51ca5-282">支持定义良好的管道输入 (SC02) </span><span class="sxs-lookup"><span data-stu-id="51ca5-282">Support Well Defined Pipeline Input (SC02)</span></span>

#### <a name="implement-for-the-middle-of-a-pipeline"></a><span data-ttu-id="51ca5-283">实现管道的中间</span><span class="sxs-lookup"><span data-stu-id="51ca5-283">Implement for the Middle of a Pipeline</span></span>

<span data-ttu-id="51ca5-284">实现一个 cmdlet，假设它将从管道的中间调用 (即，其他 cmdlet 将生成其输入或使用其输出) 。</span><span class="sxs-lookup"><span data-stu-id="51ca5-284">Implement a cmdlet assuming that it will be called from the middle of a pipeline (that is, other cmdlets will produce its input or consume its output).</span></span> <span data-ttu-id="51ca5-285">例如，你可能会认为该 `Get-Process` cmdlet 会生成数据，因为它只是管道中的第一个 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="51ca5-285">For example, you might assume that the `Get-Process` cmdlet, because it generates data, is used only as the first cmdlet in a pipeline.</span></span> <span data-ttu-id="51ca5-286">但是，由于此 cmdlet 是为管道的中间设计的，因此此 cmdlet 允许管道中的上一个 cmdlet 或数据指定要检索的进程。</span><span class="sxs-lookup"><span data-stu-id="51ca5-286">However, because this cmdlet is designed for the middle of a pipeline, this cmdlet allows previous cmdlets or data in the pipeline to specify the processes to retrieve.</span></span>

#### <a name="support-input-from-the-pipeline"></a><span data-ttu-id="51ca5-287">支持管道中的输入</span><span class="sxs-lookup"><span data-stu-id="51ca5-287">Support Input from the Pipeline</span></span>

<span data-ttu-id="51ca5-288">在 cmdlet 的每个参数集中，至少包括一个支持管道输入的参数。</span><span class="sxs-lookup"><span data-stu-id="51ca5-288">In each parameter set for a cmdlet, include at least one parameter that supports input from the pipeline.</span></span> <span data-ttu-id="51ca5-289">支持管道输入允许用户检索数据或对象，以将其发送到正确的参数集，并将结果直接传递给 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="51ca5-289">Support for pipeline input allows the user to retrieve data or objects, to send them to the correct parameter set, and to pass the results directly to a cmdlet.</span></span>

<span data-ttu-id="51ca5-290">如果**参数**属性 `ValueFromPipeline` `ValueFromPipelineByPropertyName` 在其声明中包含关键字、关键字属性或同时包含这两个关键字，则参数接受来自管道的输入。</span><span class="sxs-lookup"><span data-stu-id="51ca5-290">A parameter accepts input from the pipeline if the **Parameter** attribute includes the `ValueFromPipeline` keyword, the `ValueFromPipelineByPropertyName` keyword attribute, or both keywords in its  declaration.</span></span> <span data-ttu-id="51ca5-291">如果参数集中的参数均 `ValueFromPipeline` 不支持或 `ValueFromPipelineByPropertyName` 关键字，则无法有意义地将 cmdlet 置于另一个 cmdlet 之后，因为它将忽略任何管道输入。</span><span class="sxs-lookup"><span data-stu-id="51ca5-291">If none of the parameters in a parameter set support the `ValueFromPipeline` or `ValueFromPipelineByPropertyName` keywords, the cmdlet cannot meaningfully be placed after another cmdlet because it will ignore any pipeline input.</span></span>

#### <a name="support-the-processrecord-method"></a><span data-ttu-id="51ca5-292">支持 ProcessRecord 方法</span><span class="sxs-lookup"><span data-stu-id="51ca5-292">Support the ProcessRecord Method</span></span>

<span data-ttu-id="51ca5-293">若要接受来自管道中前面的 cmdlet 的所有记录，cmdlet 必须实现[ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord)方法。</span><span class="sxs-lookup"><span data-stu-id="51ca5-293">To accept all the records from the preceding cmdlet in the pipeline, your cmdlet must implement the [System.Management.Automation.Cmdlet.ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) method.</span></span> <span data-ttu-id="51ca5-294">Windows PowerShell 多次调用此方法，一次针对发送到 cmdlet 的每个记录调用一次。</span><span class="sxs-lookup"><span data-stu-id="51ca5-294">Windows PowerShell calls this method multiple times, once for every record that is sent to your cmdlet.</span></span>

### <a name="write-single-records-to-the-pipeline-sc03"></a><span data-ttu-id="51ca5-295">将单个记录写入管道 (SC03) </span><span class="sxs-lookup"><span data-stu-id="51ca5-295">Write Single Records to the Pipeline (SC03)</span></span>

<span data-ttu-id="51ca5-296">当 cmdlet 返回对象时，cmdlet 应在生成对象时立即写入它们。</span><span class="sxs-lookup"><span data-stu-id="51ca5-296">When a cmdlet returns objects, the cmdlet should write the objects immediately as they are generated.</span></span> <span data-ttu-id="51ca5-297">Cmdlet 不应包含它们，以便将它们缓冲到合并的数组中。</span><span class="sxs-lookup"><span data-stu-id="51ca5-297">The cmdlet should not hold them in order to buffer them into a combined array.</span></span> <span data-ttu-id="51ca5-298">作为输入接收对象的 cmdlet 将能够处理、显示或处理并显示输出对象，而无需延迟。</span><span class="sxs-lookup"><span data-stu-id="51ca5-298">The cmdlets that receive the objects as input will then be able to process, display, or process and display the output objects without delay.</span></span> <span data-ttu-id="51ca5-299">一个 cmdlet，它一次生成一个输出对象应调用[WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject)方法。</span><span class="sxs-lookup"><span data-stu-id="51ca5-299">A cmdlet that generates output objects one at a time should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="51ca5-300">一个 cmdlet，它以批处理方式生成输出对象 (例如，因为基础 API 返回输出对象的数组) 应调用[WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject)方法，并将其第二个参数设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="51ca5-300">A cmdlet that generates output objects in batches (for example, because an underlying API returns an array of output objects) should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) Method with its second parameter set to `true`.</span></span>

### <a name="make-cmdlets-case-insensitive-and-case-preserving-sc04"></a><span data-ttu-id="51ca5-301">使 Cmdlet 不区分大小写，不区分大小写 (SC04) </span><span class="sxs-lookup"><span data-stu-id="51ca5-301">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>

<span data-ttu-id="51ca5-302">默认情况下，Windows PowerShell 本身不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="51ca5-302">By default, Windows PowerShell itself is case-insensitive.</span></span> <span data-ttu-id="51ca5-303">然而，由于它处理许多预先存在的系统，因此 Windows PowerShell 确实会保留大小写，以方便操作和兼容性。</span><span class="sxs-lookup"><span data-stu-id="51ca5-303">However, because it deals with many preexisting systems, Windows PowerShell does preserve case for ease of operation and compatibility.</span></span> <span data-ttu-id="51ca5-304">换句话说，如果字符以大写字母形式提供，则 Windows PowerShell 会将其保留为大写字母。</span><span class="sxs-lookup"><span data-stu-id="51ca5-304">In other words, if a character is supplied in uppercase letters, Windows PowerShell keeps it in uppercase letters.</span></span> <span data-ttu-id="51ca5-305">为了使系统正常工作，cmdlet 需要遵循此约定。</span><span class="sxs-lookup"><span data-stu-id="51ca5-305">For systems to work well, a cmdlet needs to follow this convention.</span></span> <span data-ttu-id="51ca5-306">如果可能，它应以不区分大小写的方式运行。</span><span class="sxs-lookup"><span data-stu-id="51ca5-306">If possible, it should operate in a case-insensitive way.</span></span> <span data-ttu-id="51ca5-307">但是，它应保留在命令中或在管道中随后出现的 cmdlet 的原始事例。</span><span class="sxs-lookup"><span data-stu-id="51ca5-307">It should, however, preserve the original case for cmdlets that occur later in a command or in the pipeline.</span></span>

## <a name="see-also"></a><span data-ttu-id="51ca5-308">另请参阅</span><span class="sxs-lookup"><span data-stu-id="51ca5-308">See Also</span></span>

[<span data-ttu-id="51ca5-309">必需的开发指南</span><span class="sxs-lookup"><span data-stu-id="51ca5-309">Required Development Guidelines</span></span>](./required-development-guidelines.md)

[<span data-ttu-id="51ca5-310">咨询性的开发指南</span><span class="sxs-lookup"><span data-stu-id="51ca5-310">Advisory Development Guidelines</span></span>](./advisory-development-guidelines.md)

[<span data-ttu-id="51ca5-311">编写 Windows PowerShell Cmdlet</span><span class="sxs-lookup"><span data-stu-id="51ca5-311">Writing a Windows PowerShell Cmdlet</span></span>](./writing-a-windows-powershell-cmdlet.md)
